# Virtual Storage Simulator
### О проекте
Данный проект разрабатывается студентом кафедры 609 "Прикладная информатика" МАИ Богдановым Б.В. под научным руководством доцента кафедры, к.т.н. Терентьева М.Н. начиная с февраля 2020 года.

Этот документ содержит в себе описание репозитария, руководство пользователя, описание основных принципов, заложенных в основе симулятора и имитационной модели виртуальной памяти.

### Описание исходных файлов
Исходные файлы симулятора:
```sh
sim.cpp, sim.hpp
```
Исходные файлы с моделью системы, работающей с использованием принципов виртуальной памяти:
```sh
vm.cpp, vm.hpp
```
Файл, в котором указываются и запускаются агенты, устанавливается лимит на работу симулятора и осуществляется его запуск:
```sh
main.cpp
```
### Руководство пользователя
Прежде всего необходимо собрать исполняемый файл. Используйте команду ниже.
```sh
g++ *.cpp -o sim
```
В директории с проектом будет создан исполняемый файл sim.exe или sim.out в зависимости от операционной системы. Значения настроечных параметров устанавливаются через текстовый файл input_data.txt.

```sh
CONFIG_LOG_ENABLE_EMPTY_STRINGS=0
CONFIG_LOG_DETAIL_LEVEL=2
CONFIG_SIM_TIME_LIMIT=10000000000

AE_DEFAULT_TIME_FOR_DATA_IO=10000
AE_DEFAULT_DISKSPACE_SIZE=2000

CPU_DEFAULT_TIME_FOR_CONVERSION=1

OS_DEFAULT_PROCESS_QUEUE_TIME_LIMIT=10000
OS_DEFAULT_RAM_SIZE=700
OS_DEFAULT_TIME_FOR_ALLOCATION=100000
OS_SUBSTITUTE_STRATEGY=1

PROCESS_DEFAULT_WORK_TIME=1
PROCESS_DEFAULT_REQUESTED_MEMORY=50
PROCESS_AMOUNT=15
PROCESS_MEMORY_ACCESS_PERCENTAGE=30
```
| Параметр | Возможные значения | Описание |
| ------ | ------ | ------ |
| CONFIG_LOG_ENABLE_EMPTY_STRINGS | 1 или 0 | Включает отступы в виде пустых строк в протоколе работы симулятора. |
| CONFIG_LOG_DETAIL_LEVEL | 1, 2, 3 | Выбор степени подробности вывода данных в протокол работы симулятора. При 1-й степени отображаются только действия архивной среды. При 2-й степени отображаются сообщения о прерывания и все действия ОС по обработке этих прерываний. При 3-й степени отображаются все возможные сообщения. |
| CONFIG_SIM_TIME_LIMIT | Положительное целое число | Время симуляции в наносекундах. |
| AE_DEFAULT_TIME_FOR_DATA_IO | Положительное целое число | Время работы устройства ввода/вывода в наносекундах. |
| AE_DEFAULT_DISKSPACE_SIZE | Положительное целое число | Размер файла подкачки в количестве страниц. |
| CPU_DEFAULT_TIME_FOR_CONVERSION | Положительное целое число | Время выполнения процессором одной инструкции в наносекундах. |
| OS_DEFAULT_PROCESS_QUEUE_TIME_LIMIT | Положительное целое число | Велиина кванта времени смены очереди претендентов на процессор в наносекундах. |
| OS_DEFAULT_RAM_SIZE | Положительное целое число | Размер оперативной памяти в количестве страниц. |
| OS_DEFAULT_TIME_FOR_ALLOCATION | Положительное целое число | Время на размещения страницы в памяти в наносекундах. |
| OS_SUBSTITUTE_STRATEGY | 1, 2 | Номер стратегии выбора кандидата на перераспределение. 1 - стратегия случайного выбора. 2 - стратегия "Часы". |
| PROCESS_DEFAULT_WORK_TIME | Положительное целое число | Длительность инструкции одного процесса в наносекундах. |
| PROCESS_DEFAULT_REQUESTED_MEMORY | Положительное целое число | Память, необходимая процессу в количестве страниц. |
| PROCESS_AMOUNT | Положительное целое число | Количество процессов в системе. |
| PROCESS_MEMORY_ACCESS_PERCENTAGE | Целое число от 0 до 100 | Процент инструкций, требующих обращения в память. |

После установки необходимых параметров все готово к симуляции. Запуск симуляции происходит одновременно с запуком исполняемого файла. Симуляция автоматически завершится при достижении временного ограничения, установленного параметром CONFIG_SIM_TIME_LIMIT.
Для принудительного завершения симуляция следует использовать сочетание клавиш Ctrl + C.
### Описание симулятора
В этом симуляторе моделируются адреса, но не данные, которые хранятся по этим адресам. Структуризация памяти страничная.
В модели присутствуют следующие агенты: центральный процессор (ЦП), операционная система (ОС), архивная среда (АС) и процесс.

- Центральный процессор (ЦП) выполняет только одну задачу – задачу преобразования адреса;
- Операционная система (ОС) - многозадачный агент, в котором моделируется сама работа с виртуальной памятью, а также такие сущности, как таблицы переадресации (ТП), реальное адресное пространство (РАП), обработчик очереди претендентов на ЦП, планировщик ввода/вывода в/из АС;
- Архивная среда (АС) занимается непосредственно моделированием ввода/вывода в АС, кстати архивное адресное пространство (ААП) также смоделировано в этом агенте;
- Процесс – агент, в котором с смоделировано обращение к случайным адресам своего виртуального адресного пространства (ВАП), а также счётчик времени, которое осталось от кванта, на который процессу даются вычислительные мощности ЦП. Процессов может быть несколько, что нельзя сказать об остальных агентах. 

### Как это работает?
#### Общими словами
В main.cpp создается множество процессов, которое далее будет функционировать во всей системе, при этом у каждого объекта класса-агента процесс вызывается специальный метод Start(). В методе Start() происходит планирование метода LoadProcess() класса-агента ОС, таким образом каждый процесс как бы оповещает ОС о своем существовании. Узнав об очередном новом процессе, ОС выделяет память под его ТП и добавляет этот процесс в очередь претендентов на ЦП. Как только хоть один процесс появляется в очереди, ОС немедленно начинает её обработку вызовом метода ProcessQueue(), процесс начинает работать в своем ВАП. Эта работа продолжается непродолжительный промежуток времени, называемый квантом, когда очередной процесс “исчерпал” свой квант времени, обработчик ставит этот процесс в конец очереди, а сам предоставляет ЦП другому претенденту --- это смоделировано в методе ChangeQueue().

Если подвести итоги вышесказанному, можно выделить следующую цепочку событий: Process.Start() -> OS.LoadProcess() -> OS.Scheduler.AddProcess() -> OS.ProcessQueue() -> Process.Work() -> CPU.Convert() ->   в случае, если квант не исчерпан еще раз Process.Work() -> …, в случае если исчерпан, то OS.ChangeQueue() -> OS.ProcessQueue() -> …

Другими словами, каждое исполнение метода Work() порождает одно исполнение метода Convert(), которое, в свою очередь, через проверку на исчерпание кванта породит еще один метод Work() или же, в случае прерывания, через его обработку, методы Allocate() и Substitute() также через проверку на исчерпание кванта породит еще один метод Work(). Круг замкнут, именно поэтому модель непрерывно работает.

> **Замечание:** Хоть и метод Convert() находится в классе-агенте ЦП, на деле же получается, что в этом методе происходит поиск нужной ТП, а затем и нужной записи этой ТП. Этот поиск реализован в методе FindTT у операционной системы (ОС), а значит ЦП только вызывает этот метод.

#### Принцип обработки очереди планировщика
Прежде всего стоит сказать, что счетчик кванта времени инкапсулирован в каждом отдельном процессе (хотя, вообще говоря, можно было бы вести этот подсчет и в классе ОС, но это на самом деле не суть важно). Ну и повторюсь, что сама проверка выполняется следующим образом:

Если счетчик времени больше нуля, значит квант времени еще не исчерпан, отнимаем от счётчика необходимое количество времени (например, время, необходимое на преобразование адреса – метод Convert()) и, соответственно, планируем следующий метод Work(), в ином случае планируем метод ChangeQueue().
Несложно отметить, что при любых обстоятельствах рано или поздно в очередь претендентов добавляется претендент в силу того, что в симуляторе должны присутствовать объекты всех классов-агентов, а процесс – хотя бы в единичном экземпляре.

Если на момент добавления претендента очередь пуста, планируем событие обработки очереди ProcessQueue(), которое устанавливает для очередного процесса квант времени (устанавливается счетчик времени), планируется работа этого процесса.

#### Обработка страничного прерывания
Специально для этого разработан метод HandelInterruption() у класса-агента ОС, который как раз моделирует обработку прерывания по отсутствию страницы. Итак, вот как это происходит:
1.	Когда происходит прерывание по отсутствию страницы, планируется метод HandelInterruption().
2.	Если виртуальный адрес из-за преобразования которого произошло прерывание по отсутствию страницы был ранее загружен в АС, необходимо запланировать запрос на выгрузку данных из АС.
3.	Вызываем метод Allocate() класса-агента ОС, который попытается найти в РАП свободный (ранее нераспределенный ни разу) реальный адрес. Если такой адрес найден, можно сказать, что обработка прерывания завершена, только перед тем, как планировать последующую работу процесса, также как и в методе Convert(), проверим, не исчерпан ли квант; если же свободных адресов нет, вызываем метод Substitute().
4.	В методе Substitute() класса-агента ОС моделируется задача поиска претендента на перераспределение адреса, в текущей модели этот алгоритм основан на принципе случайного выбора, когда претендент будет найден, спланируем работу процесса, в очередной раз проверив, чтобы квант времени не был исчерпан.

#### Обработка очереди запросов к архивной среде
Главная особенность модели заключается в том, что очередь может обрабатываться (и так чаще всего и происходит) параллельно другим действия системы. Например, ЦП уже вызывает прерывание по отсутствию страницы для некоторого процесса под именем Process10, а в это же время АС выполняет загрузку данных по виртуальному адресу процесса Process09.
Обработка очереди запросов к АС происходит, в целом, по тому же принципу, что и обработка очереди претендентов, за тем лишь одним исключением, что ввод/вывод данных в/из АС происходит только тогда, когда в очереди есть хоть один запрос.
